# 快速开始 - 5 分钟上手

## 核心概念 (30 秒理解)

```
发布者：dispatcher->publish(msg)    →  [Dispatcher]  → 订阅者：co_await queue->async_read_msg()
```

就这么简单！

## 最小示例 (复制即用)

```cpp
#include "dispatcher.hpp"
#include <asio.hpp>
#include <asio/co_spawn.hpp>
#include <asio/use_awaitable.hpp>
#include <iostream>

using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable;

// 订阅者协程
awaitable<void> subscriber(std::shared_ptr<bcast::async_queue<std::string>> queue) {
    while (true) {
        auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);
        if (ec) break;
        std::cout << "收到: " << msg << std::endl;
    }
}

int main() {
    asio::io_context io;
    
    // 1. 创建 dispatcher
    auto disp = bcast::make_dispatcher<std::string>(io);
    
    // 2. 订阅（获取队列）
    auto queue = disp->subscribe();
    
    // 3. 启动订阅者协程
    co_spawn(io, subscriber(queue), detached);
    
    // 4. 发布消息
    disp->publish("Hello");
    disp->publish("World");
    
    // 5. 运行
    io.run();
    return 0;
}
```

### 编译
```bash
g++ -std=c++20 -fcoroutines example.cpp -lpthread -o example
./example
```

## 常见场景

### 场景 1: 多个订阅者

```cpp
auto queue1 = disp->subscribe();
auto queue2 = disp->subscribe();
auto queue3 = disp->subscribe();

co_spawn(io, subscriber(queue1, "订阅者1"), detached);
co_spawn(io, subscriber(queue2, "订阅者2"), detached);
co_spawn(io, subscriber(queue3, "订阅者3"), detached);

disp->publish("广播消息");  // 所有订阅者都收到
```

### 场景 2: 批量读取

```cpp
awaitable<void> batch_reader(auto queue) {
    while (true) {
        // 一次读最多 10 条
        auto [ec, messages] = co_await queue->async_read_msgs(10, use_awaitable);
        if (ec) break;
        
        std::cout << "收到 " << messages.size() << " 条消息" << std::endl;
        for (const auto& msg : messages) {
            process(msg);
        }
    }
}
```

### 场景 3: 带错误处理

```cpp
awaitable<void> safe_subscriber(auto queue) {
    try {
        while (true) {
            auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);
            
            if (ec) {
                std::cerr << "错误: " << ec.message() << std::endl;
                break;
            }
            
            process(msg);
        }
    } catch (const std::exception& e) {
        std::cerr << "异常: " << e.what() << std::endl;
    }
}
```

### 场景 4: 超时读取

```cpp
using namespace std::chrono_literals;

awaitable<void> reader_with_timeout(auto queue) {
    while (true) {
        // 最多等待 5 秒
        auto [ec, msg] = co_await queue->async_read_msg_with_timeout(5s, use_awaitable);
        
        if (ec == asio::error::timed_out) {
            std::cout << "超时，执行定期任务..." << std::endl;
            perform_periodic_task();
            continue;
        }
        
        if (ec) break;
        
        std::cout << "收到: " << msg << std::endl;
    }
}
```

### 场景 5: 从多个线程发布

```cpp
auto disp = bcast::make_dispatcher<int>(io);
auto queue = disp->subscribe();

// 启动订阅者
co_spawn(io, subscriber(queue), detached);

// 启动多个发布者线程
std::vector<std::thread> publishers;
for (int t = 0; t < 4; ++t) {
    publishers.emplace_back([&disp, t]() {
        for (int i = 0; i < 100; ++i) {
            disp->publish(t * 100 + i);  // 线程安全！
        }
    });
}

// 运行
io.run();

// 等待发布者
for (auto& t : publishers) {
    t.join();
}
```

## API 速查表

### Dispatcher

| 方法 | 说明 | 示例 |
|------|------|------|
| `subscribe()` | 订阅，返回队列 | `auto q = disp->subscribe();` |
| `publish(msg)` | 发布消息 | `disp->publish("hello");` |
| `unsubscribe(queue)` | 取消订阅 | `disp->unsubscribe(q);` |
| `clear()` | 清空所有订阅者 | `disp->clear();` |

### Async Queue

| 方法 | 说明 | 示例 |
|------|------|------|
| `async_read_msg()` | 读单条消息 | `auto [ec, msg] = co_await q->async_read_msg(use_awaitable);` |
| `async_read_msgs(n)` | 读多条消息 | `auto [ec, msgs] = co_await q->async_read_msgs(10, use_awaitable);` |
| `async_read_msg_with_timeout(t)` | 读单条消息（超时） | `auto [ec, msg] = co_await q->async_read_msg_with_timeout(5s, use_awaitable);` |
| `async_read_msgs_with_timeout(n,t)` | 读多条消息（超时） | `auto [ec, msgs] = co_await q->async_read_msgs_with_timeout(10, 5s, use_awaitable);` |
| `stop()` | 停止队列 | `q->stop();` |
| `is_stopped()` | 检查是否停止 | `if (q->is_stopped()) ...` |
| `size()` | 队列大小 | `auto size = q->size();` |

## 完整的实际例子

### 聊天室

```cpp
#include "dispatcher.hpp"
#include <asio.hpp>
#include <asio/co_spawn.hpp>
#include <asio/use_awaitable.hpp>

using asio::awaitable;
using asio::use_awaitable;

struct ChatMsg {
    std::string user;
    std::string text;
};

awaitable<void> chat_user(auto queue, std::string name) {
    std::cout << name << " 加入聊天室" << std::endl;
    
    while (true) {
        auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);
        if (ec) break;
        
        if (msg.user != name) {  // 不显示自己的消息
            std::cout << "[" << name << "] 看到 " 
                      << msg.user << ": " << msg.text << std::endl;
        }
    }
}

int main() {
    asio::io_context io;
    auto chat = bcast::make_dispatcher<ChatMsg>(io);
    
    // 创建用户
    auto alice_q = chat->subscribe();
    auto bob_q = chat->subscribe();
    
    co_spawn(io, chat_user(alice_q, "Alice"), asio::detached);
    co_spawn(io, chat_user(bob_q, "Bob"), asio::detached);
    
    // 模拟聊天
    chat->publish(ChatMsg{"Alice", "大家好！"});
    chat->publish(ChatMsg{"Bob", "嗨 Alice！"});
    chat->publish(ChatMsg{"Alice", "今天天气真好"});
    
    io.run();
    return 0;
}
```

输出：
```
Alice 加入聊天室
Bob 加入聊天室
[Bob] 看到 Alice: 大家好！
[Alice] 看到 Bob: 嗨 Alice！
[Bob] 看到 Alice: 今天天气真好
```

## 常见问题

### Q: 需要 C++20 吗？
A: 协程 API 需要 C++20。如果不能用 C++20，我们也提供了回调版本（见旧的 API）。

### Q: 如何停止订阅者？
A: 有几种方式：
```cpp
// 方式 1: 停止队列
queue->stop();

// 方式 2: 取消订阅
dispatcher->unsubscribe(queue);

// 方式 3: 在协程中退出循环
if (should_stop) break;
```

### Q: 消息会丢失吗？
A: 不会。消息在队列中排队，按顺序处理。

### Q: 支持多线程吗？
A: 完全支持！所有 API 都是线程安全的。

### Q: 性能如何？
A: 非常高效：
- 无锁设计
- 零拷贝（使用移动语义）
- 低延迟（微秒级）

## 下一步

- 📖 阅读 [协程API指南.md](协程API指南.md) 了解详细用法
- 🔍 查看 [API对比.md](API对比.md) 了解回调 vs 协程
- 🚀 运行示例：
  ```bash
  cd src/bcast
  g++ -std=c++20 coroutine_example.cpp -lpthread -o example
  ./example
  ```

## 记住这三步

1. **创建 dispatcher**：`auto disp = make_dispatcher<T>(io);`
2. **订阅**：`auto queue = disp->subscribe();`
3. **读取**：`auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);`

就是这么简单！🎉

