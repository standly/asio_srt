# å¿«é€Ÿå¼€å§‹ - 5 åˆ†é’Ÿä¸Šæ‰‹

## æ ¸å¿ƒæ¦‚å¿µ (30 ç§’ç†è§£)

```
å‘å¸ƒè€…ï¼šdispatcher->publish(msg)    â†’  [Dispatcher]  â†’ è®¢é˜…è€…ï¼šco_await queue->async_read_msg()
```

å°±è¿™ä¹ˆç®€å•ï¼

## æœ€å°ç¤ºä¾‹ (å¤åˆ¶å³ç”¨)

```cpp
#include "dispatcher.hpp"
#include <asio.hpp>
#include <asio/co_spawn.hpp>
#include <asio/use_awaitable.hpp>
#include <iostream>

using asio::awaitable;
using asio::co_spawn;
using asio::detached;
using asio::use_awaitable;

// è®¢é˜…è€…åç¨‹
awaitable<void> subscriber(std::shared_ptr<bcast::async_queue<std::string>> queue) {
    while (true) {
        auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);
        if (ec) break;
        std::cout << "æ”¶åˆ°: " << msg << std::endl;
    }
}

int main() {
    asio::io_context io;
    
    // 1. åˆ›å»º dispatcher
    auto disp = bcast::make_dispatcher<std::string>(io);
    
    // 2. è®¢é˜…ï¼ˆè·å–é˜Ÿåˆ—ï¼‰
    auto queue = disp->subscribe();
    
    // 3. å¯åŠ¨è®¢é˜…è€…åç¨‹
    co_spawn(io, subscriber(queue), detached);
    
    // 4. å‘å¸ƒæ¶ˆæ¯
    disp->publish("Hello");
    disp->publish("World");
    
    // 5. è¿è¡Œ
    io.run();
    return 0;
}
```

### ç¼–è¯‘
```bash
g++ -std=c++20 -fcoroutines example.cpp -lpthread -o example
./example
```

## å¸¸è§åœºæ™¯

### åœºæ™¯ 1: å¤šä¸ªè®¢é˜…è€…

```cpp
auto queue1 = disp->subscribe();
auto queue2 = disp->subscribe();
auto queue3 = disp->subscribe();

co_spawn(io, subscriber(queue1, "è®¢é˜…è€…1"), detached);
co_spawn(io, subscriber(queue2, "è®¢é˜…è€…2"), detached);
co_spawn(io, subscriber(queue3, "è®¢é˜…è€…3"), detached);

disp->publish("å¹¿æ’­æ¶ˆæ¯");  // æ‰€æœ‰è®¢é˜…è€…éƒ½æ”¶åˆ°
```

### åœºæ™¯ 2: æ‰¹é‡è¯»å–

```cpp
awaitable<void> batch_reader(auto queue) {
    while (true) {
        // ä¸€æ¬¡è¯»æœ€å¤š 10 æ¡
        auto [ec, messages] = co_await queue->async_read_msgs(10, use_awaitable);
        if (ec) break;
        
        std::cout << "æ”¶åˆ° " << messages.size() << " æ¡æ¶ˆæ¯" << std::endl;
        for (const auto& msg : messages) {
            process(msg);
        }
    }
}
```

### åœºæ™¯ 3: å¸¦é”™è¯¯å¤„ç†

```cpp
awaitable<void> safe_subscriber(auto queue) {
    try {
        while (true) {
            auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);
            
            if (ec) {
                std::cerr << "é”™è¯¯: " << ec.message() << std::endl;
                break;
            }
            
            process(msg);
        }
    } catch (const std::exception& e) {
        std::cerr << "å¼‚å¸¸: " << e.what() << std::endl;
    }
}
```

### åœºæ™¯ 4: è¶…æ—¶è¯»å–

```cpp
using namespace std::chrono_literals;

awaitable<void> reader_with_timeout(auto queue) {
    while (true) {
        // æœ€å¤šç­‰å¾… 5 ç§’
        auto [ec, msg] = co_await queue->async_read_msg_with_timeout(5s, use_awaitable);
        
        if (ec == asio::error::timed_out) {
            std::cout << "è¶…æ—¶ï¼Œæ‰§è¡Œå®šæœŸä»»åŠ¡..." << std::endl;
            perform_periodic_task();
            continue;
        }
        
        if (ec) break;
        
        std::cout << "æ”¶åˆ°: " << msg << std::endl;
    }
}
```

### åœºæ™¯ 5: ä»å¤šä¸ªçº¿ç¨‹å‘å¸ƒ

```cpp
auto disp = bcast::make_dispatcher<int>(io);
auto queue = disp->subscribe();

// å¯åŠ¨è®¢é˜…è€…
co_spawn(io, subscriber(queue), detached);

// å¯åŠ¨å¤šä¸ªå‘å¸ƒè€…çº¿ç¨‹
std::vector<std::thread> publishers;
for (int t = 0; t < 4; ++t) {
    publishers.emplace_back([&disp, t]() {
        for (int i = 0; i < 100; ++i) {
            disp->publish(t * 100 + i);  // çº¿ç¨‹å®‰å…¨ï¼
        }
    });
}

// è¿è¡Œ
io.run();

// ç­‰å¾…å‘å¸ƒè€…
for (auto& t : publishers) {
    t.join();
}
```

## API é€ŸæŸ¥è¡¨

### Dispatcher

| æ–¹æ³• | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| `subscribe()` | è®¢é˜…ï¼Œè¿”å›é˜Ÿåˆ— | `auto q = disp->subscribe();` |
| `publish(msg)` | å‘å¸ƒæ¶ˆæ¯ | `disp->publish("hello");` |
| `unsubscribe(queue)` | å–æ¶ˆè®¢é˜… | `disp->unsubscribe(q);` |
| `clear()` | æ¸…ç©ºæ‰€æœ‰è®¢é˜…è€… | `disp->clear();` |

### Async Queue

| æ–¹æ³• | è¯´æ˜ | ç¤ºä¾‹ |
|------|------|------|
| `async_read_msg()` | è¯»å•æ¡æ¶ˆæ¯ | `auto [ec, msg] = co_await q->async_read_msg(use_awaitable);` |
| `async_read_msgs(n)` | è¯»å¤šæ¡æ¶ˆæ¯ | `auto [ec, msgs] = co_await q->async_read_msgs(10, use_awaitable);` |
| `async_read_msg_with_timeout(t)` | è¯»å•æ¡æ¶ˆæ¯ï¼ˆè¶…æ—¶ï¼‰ | `auto [ec, msg] = co_await q->async_read_msg_with_timeout(5s, use_awaitable);` |
| `async_read_msgs_with_timeout(n,t)` | è¯»å¤šæ¡æ¶ˆæ¯ï¼ˆè¶…æ—¶ï¼‰ | `auto [ec, msgs] = co_await q->async_read_msgs_with_timeout(10, 5s, use_awaitable);` |
| `stop()` | åœæ­¢é˜Ÿåˆ— | `q->stop();` |
| `is_stopped()` | æ£€æŸ¥æ˜¯å¦åœæ­¢ | `if (q->is_stopped()) ...` |
| `size()` | é˜Ÿåˆ—å¤§å° | `auto size = q->size();` |

## å®Œæ•´çš„å®é™…ä¾‹å­

### èŠå¤©å®¤

```cpp
#include "dispatcher.hpp"
#include <asio.hpp>
#include <asio/co_spawn.hpp>
#include <asio/use_awaitable.hpp>

using asio::awaitable;
using asio::use_awaitable;

struct ChatMsg {
    std::string user;
    std::string text;
};

awaitable<void> chat_user(auto queue, std::string name) {
    std::cout << name << " åŠ å…¥èŠå¤©å®¤" << std::endl;
    
    while (true) {
        auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);
        if (ec) break;
        
        if (msg.user != name) {  // ä¸æ˜¾ç¤ºè‡ªå·±çš„æ¶ˆæ¯
            std::cout << "[" << name << "] çœ‹åˆ° " 
                      << msg.user << ": " << msg.text << std::endl;
        }
    }
}

int main() {
    asio::io_context io;
    auto chat = bcast::make_dispatcher<ChatMsg>(io);
    
    // åˆ›å»ºç”¨æˆ·
    auto alice_q = chat->subscribe();
    auto bob_q = chat->subscribe();
    
    co_spawn(io, chat_user(alice_q, "Alice"), asio::detached);
    co_spawn(io, chat_user(bob_q, "Bob"), asio::detached);
    
    // æ¨¡æ‹ŸèŠå¤©
    chat->publish(ChatMsg{"Alice", "å¤§å®¶å¥½ï¼"});
    chat->publish(ChatMsg{"Bob", "å—¨ Aliceï¼"});
    chat->publish(ChatMsg{"Alice", "ä»Šå¤©å¤©æ°”çœŸå¥½"});
    
    io.run();
    return 0;
}
```

è¾“å‡ºï¼š
```
Alice åŠ å…¥èŠå¤©å®¤
Bob åŠ å…¥èŠå¤©å®¤
[Bob] çœ‹åˆ° Alice: å¤§å®¶å¥½ï¼
[Alice] çœ‹åˆ° Bob: å—¨ Aliceï¼
[Bob] çœ‹åˆ° Alice: ä»Šå¤©å¤©æ°”çœŸå¥½
```

## å¸¸è§é—®é¢˜

### Q: éœ€è¦ C++20 å—ï¼Ÿ
A: åç¨‹ API éœ€è¦ C++20ã€‚å¦‚æœä¸èƒ½ç”¨ C++20ï¼Œæˆ‘ä»¬ä¹Ÿæä¾›äº†å›è°ƒç‰ˆæœ¬ï¼ˆè§æ—§çš„ APIï¼‰ã€‚

### Q: å¦‚ä½•åœæ­¢è®¢é˜…è€…ï¼Ÿ
A: æœ‰å‡ ç§æ–¹å¼ï¼š
```cpp
// æ–¹å¼ 1: åœæ­¢é˜Ÿåˆ—
queue->stop();

// æ–¹å¼ 2: å–æ¶ˆè®¢é˜…
dispatcher->unsubscribe(queue);

// æ–¹å¼ 3: åœ¨åç¨‹ä¸­é€€å‡ºå¾ªç¯
if (should_stop) break;
```

### Q: æ¶ˆæ¯ä¼šä¸¢å¤±å—ï¼Ÿ
A: ä¸ä¼šã€‚æ¶ˆæ¯åœ¨é˜Ÿåˆ—ä¸­æ’é˜Ÿï¼ŒæŒ‰é¡ºåºå¤„ç†ã€‚

### Q: æ”¯æŒå¤šçº¿ç¨‹å—ï¼Ÿ
A: å®Œå…¨æ”¯æŒï¼æ‰€æœ‰ API éƒ½æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

### Q: æ€§èƒ½å¦‚ä½•ï¼Ÿ
A: éå¸¸é«˜æ•ˆï¼š
- æ— é”è®¾è®¡
- é›¶æ‹·è´ï¼ˆä½¿ç”¨ç§»åŠ¨è¯­ä¹‰ï¼‰
- ä½å»¶è¿Ÿï¼ˆå¾®ç§’çº§ï¼‰

## ä¸‹ä¸€æ­¥

- ğŸ“– é˜…è¯» [åç¨‹APIæŒ‡å—.md](åç¨‹APIæŒ‡å—.md) äº†è§£è¯¦ç»†ç”¨æ³•
- ğŸ” æŸ¥çœ‹ [APIå¯¹æ¯”.md](APIå¯¹æ¯”.md) äº†è§£å›è°ƒ vs åç¨‹
- ğŸš€ è¿è¡Œç¤ºä¾‹ï¼š
  ```bash
  cd src/bcast
  g++ -std=c++20 coroutine_example.cpp -lpthread -o example
  ./example
  ```

## è®°ä½è¿™ä¸‰æ­¥

1. **åˆ›å»º dispatcher**ï¼š`auto disp = make_dispatcher<T>(io);`
2. **è®¢é˜…**ï¼š`auto queue = disp->subscribe();`
3. **è¯»å–**ï¼š`auto [ec, msg] = co_await queue->async_read_msg(use_awaitable);`

å°±æ˜¯è¿™ä¹ˆç®€å•ï¼ğŸ‰

