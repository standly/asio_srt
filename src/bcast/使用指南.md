# 异步发布订阅模式使用指南

## 目录
1. [概述](#概述)
2. [核心概念](#核心概念)
3. [快速开始](#快速开始)
4. [API 参考](#api-参考)
5. [最佳实践](#最佳实践)
6. [性能优化](#性能优化)
7. [常见问题](#常见问题)

## 概述

这是一个基于 ASIO 的异步、无锁发布订阅模式实现。核心特点：

- ✅ **无锁设计**：使用 ASIO strand 实现线程安全，无需 mutex
- ✅ **异步处理**：所有操作都是异步的，不会阻塞
- ✅ **类型安全**：使用 C++ 模板，编译期类型检查
- ✅ **高性能**：零锁开销，低延迟消息传递
- ✅ **易于使用**：简洁的 API，支持 lambda 表达式

## 核心概念

### Strand（执行序列）

Strand 是 ASIO 提供的一种机制，用于序列化事件处理：

```
多线程环境                 Strand                处理函数
   Thread 1  ──┐
   Thread 2  ──┤──> [队列化] ──> 按序执行 ──> Handler 1, 2, 3...
   Thread 3  ──┘
```

**优势**：
- 无需显式锁定
- 避免竞态条件
- 保证操作顺序性

### async_queue（异步队列）

每个订阅者都有独立的消息队列：

```
发布者                     订阅者队列
         ┌──> Queue 1 ──> 订阅者 1
Publish ─┼──> Queue 2 ──> 订阅者 2
         └──> Queue 3 ──> 订阅者 3
```

**特性**：
- 独立处理：各订阅者互不影响
- 异步推送：不阻塞发布者
- 异常隔离：某个订阅者出错不影响其他订阅者

### dispatcher（分发器）

管理所有订阅者，负责消息路由：

```
              ┌─────────────────┐
              │   Dispatcher    │
              │  [Subscribers]  │
              └─────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
   Subscriber 1  Subscriber 2  Subscriber 3
```

## 快速开始

### 1. 基本示例

```cpp
#include "dispatcher.hpp"
#include <asio.hpp>

int main() {
    // 创建 io_context
    asio::io_context io_context;
    
    // 创建 dispatcher（字符串类型消息）
    auto dispatcher = bcast::make_dispatcher<std::string>(io_context);
    
    // 订阅消息
    auto subscriber_id = dispatcher->subscribe([](const std::string& msg) {
        std::cout << "收到消息: " << msg << std::endl;
    });
    
    // 发布消息
    dispatcher->publish("Hello, World!");
    dispatcher->publish("这是第二条消息");
    
    // 运行 io_context（处理异步操作）
    io_context.run();
    
    // 取消订阅
    dispatcher->unsubscribe(subscriber_id);
    
    return 0;
}
```

### 2. 多订阅者示例

```cpp
auto dispatcher = bcast::make_dispatcher<int>(io_context);

// 订阅者 1：打印所有数字
auto sub1 = dispatcher->subscribe([](int value) {
    std::cout << "订阅者1 收到: " << value << std::endl;
});

// 订阅者 2：只处理偶数
auto sub2 = dispatcher->subscribe([](int value) {
    if (value % 2 == 0) {
        std::cout << "订阅者2 处理偶数: " << value << std::endl;
    }
});

// 订阅者 3：计算累加和
int sum = 0;
auto sub3 = dispatcher->subscribe([&sum](int value) {
    sum += value;
    std::cout << "当前总和: " << sum << std::endl;
});

// 发布一系列数字
for (int i = 1; i <= 10; ++i) {
    dispatcher->publish(i);
}

io_context.run();
```

### 3. 自定义消息类型

```cpp
// 定义消息结构
struct SensorData {
    std::string sensor_id;
    double temperature;
    double humidity;
    int64_t timestamp;
};

// 创建 dispatcher
auto dispatcher = bcast::make_dispatcher<SensorData>(io_context);

// 订阅
auto sub = dispatcher->subscribe([](const SensorData& data) {
    std::cout << "传感器 " << data.sensor_id 
              << ": 温度=" << data.temperature 
              << "°C, 湿度=" << data.humidity << "%" 
              << std::endl;
});

// 发布传感器数据
dispatcher->publish(SensorData{
    "sensor_01", 
    25.5, 
    60.0, 
    std::time(nullptr)
});
```

## API 参考

### async_queue<T>

#### 构造函数
```cpp
async_queue(asio::io_context& io_context, message_handler handler)
```

#### 方法

| 方法 | 描述 | 线程安全 |
|------|------|----------|
| `void push(T msg)` | 推送消息到队列 | ✅ |
| `void stop()` | 停止队列，清空所有消息 | ✅ |
| `void set_error_handler(error_handler h)` | 设置异常处理器 | ❌ |
| `void get_size(callback)` | 异步获取队列大小 | ✅ |

### dispatcher<T>

#### 创建

```cpp
// 方法 1：直接构造
auto disp = std::make_shared<bcast::dispatcher<T>>(io_context);

// 方法 2：使用工厂函数（推荐）
auto disp = bcast::make_dispatcher<T>(io_context);
```

#### 方法

| 方法 | 描述 | 返回值 | 线程安全 |
|------|------|--------|----------|
| `subscribe(handler)` | 订阅消息 | subscriber_id | ✅ |
| `unsubscribe(id)` | 取消订阅 | void | ✅ |
| `publish(msg)` | 发布消息给所有订阅者 | void | ✅ |
| `get_subscriber_count(callback)` | 获取订阅者数量 | void | ✅ |
| `clear()` | 清除所有订阅者 | void | ✅ |

## 最佳实践

### 1. io_context 的生命周期管理

```cpp
// ❌ 错误：io_context 过早销毁
void bad_example() {
    asio::io_context io_context;
    auto disp = bcast::make_dispatcher<int>(io_context);
    disp->publish(42);
} // io_context 销毁，消息未处理

// ✅ 正确：确保 io_context 运行
void good_example() {
    asio::io_context io_context;
    auto disp = bcast::make_dispatcher<int>(io_context);
    
    disp->subscribe([](int v) { 
        std::cout << v << std::endl; 
    });
    
    disp->publish(42);
    
    // 运行直到所有任务完成
    io_context.run();
}
```

### 2. 多线程环境

```cpp
asio::io_context io_context;
auto dispatcher = bcast::make_dispatcher<std::string>(io_context);

// 订阅
auto sub = dispatcher->subscribe([](const std::string& msg) {
    // 处理消息
    std::cout << "[" << std::this_thread::get_id() << "] " << msg << std::endl;
});

// 启动多个工作线程
std::vector<std::thread> workers;
for (int i = 0; i < 4; ++i) {
    workers.emplace_back([&io_context]() {
        io_context.run();
    });
}

// 从任意线程发布消息（线程安全）
std::thread publisher([&]() {
    for (int i = 0; i < 100; ++i) {
        dispatcher->publish("消息 " + std::to_string(i));
    }
});

publisher.join();

// 停止并等待所有工作线程
io_context.stop();
for (auto& t : workers) {
    t.join();
}
```

### 3. 异常处理

```cpp
auto queue = std::make_shared<bcast::async_queue<int>>(
    io_context, 
    [](int value) {
        if (value < 0) {
            throw std::runtime_error("负数不允许");
        }
        process(value);
    }
);

// 设置异常处理器
queue->set_error_handler([](const std::exception& e) {
    std::cerr << "处理异常: " << e.what() << std::endl;
    // 记录日志、发送告警等
});
```

### 4. 使用 shared_ptr 优化大消息

```cpp
// 假设消息很大
struct LargeData {
    std::vector<uint8_t> buffer;  // 可能有几 MB
    // ... 其他字段
};

// ❌ 低效：每个订阅者都复制整个消息
auto disp1 = bcast::make_dispatcher<LargeData>(io_context);
disp1->publish(large_data);  // 复制开销大

// ✅ 高效：使用 shared_ptr，只复制指针
using LargeDataPtr = std::shared_ptr<LargeData>;
auto disp2 = bcast::make_dispatcher<LargeDataPtr>(io_context);

auto data = std::make_shared<LargeData>();
data->buffer.resize(1024 * 1024);  // 1MB
disp2->publish(data);  // 只复制指针，开销小
```

### 5. 订阅者生命周期管理

```cpp
class MessageHandler {
public:
    MessageHandler(std::shared_ptr<bcast::dispatcher<int>> disp) 
        : dispatcher_(disp) 
    {
        // 订阅时保存 ID
        subscriber_id_ = dispatcher_->subscribe([this](int value) {
            this->handle_message(value);
        });
    }
    
    ~MessageHandler() {
        // 析构时自动取消订阅
        if (auto disp = dispatcher_.lock()) {
            disp->unsubscribe(subscriber_id_);
        }
    }
    
private:
    void handle_message(int value) {
        std::cout << "处理: " << value << std::endl;
    }
    
    std::weak_ptr<bcast::dispatcher<int>> dispatcher_;
    uint64_t subscriber_id_;
};
```

## 性能优化

### 1. 减少消息复制

```cpp
// 使用 move 语义
struct Message {
    std::string data;
    Message(std::string d) : data(std::move(d)) {}
};

// 或者使用 shared_ptr
using MessagePtr = std::shared_ptr<Message>;
```

### 2. 批量处理

```cpp
auto dispatcher = bcast::make_dispatcher<int>(io_context);

std::vector<int> batch;
dispatcher->subscribe([&batch](int value) {
    batch.push_back(value);
    
    if (batch.size() >= 100) {
        // 批量处理 100 条消息
        process_batch(batch);
        batch.clear();
    }
});
```

### 3. 选择性订阅

```cpp
// 在订阅者内部过滤，而不是创建多个 dispatcher
dispatcher->subscribe([](const Message& msg) {
    // 只处理感兴趣的消息
    if (msg.type == MessageType::IMPORTANT) {
        handle(msg);
    }
});
```

### 4. io_context 线程池大小

```cpp
// 根据 CPU 核心数调整线程池大小
unsigned int thread_count = std::thread::hardware_concurrency();

std::vector<std::thread> pool;
for (unsigned int i = 0; i < thread_count; ++i) {
    pool.emplace_back([&io_context]() {
        io_context.run();
    });
}
```

## 常见问题

### Q1: 消息没有被处理？

**A:** 确保 `io_context.run()` 被调用：

```cpp
io_context.run();  // 必须调用才能处理异步操作
```

### Q2: 如何保证消息顺序？

**A:** 对于单个订阅者，消息顺序是保证的。如果需要全局顺序，使用单线程运行 io_context：

```cpp
// 单线程，保证全局顺序
io_context.run();
```

### Q3: 订阅者可以在回调中取消订阅吗？

**A:** 可以，但需要小心：

```cpp
uint64_t sub_id;
sub_id = dispatcher->subscribe([&](const Message& msg) {
    if (msg.type == "stop") {
        // 异步取消订阅，避免在回调中直接操作
        asio::post(io_context, [&]() {
            dispatcher->unsubscribe(sub_id);
        });
    }
});
```

### Q4: 如何实现请求-响应模式？

**A:** 使用两个 dispatcher 或在消息中包含回调：

```cpp
struct Request {
    int id;
    std::string data;
    std::function<void(Response)> callback;
};

dispatcher->subscribe([](const Request& req) {
    Response resp = process(req.data);
    req.callback(resp);  // 调用回调返回结果
});
```

### Q5: 性能瓶颈在哪里？

**A:** 主要瓶颈：
1. 消息复制 → 使用 `shared_ptr`
2. 订阅者处理慢 → 每个订阅者有独立队列，不会互相阻塞
3. 单线程 io_context → 使用多线程池

### Q6: 如何调试？

```cpp
// 添加日志
dispatcher->subscribe([](const Message& msg) {
    std::cout << "[" << std::this_thread::get_id() << "] "
              << "处理消息: " << msg.id << std::endl;
});

// 监控队列大小
queue->get_size([](size_t size) {
    if (size > 1000) {
        std::cout << "警告：队列积压 " << size << " 条消息" << std::endl;
    }
});
```

## 编译和运行

### 编译示例程序

```bash
cd /home/ubuntu/codes/cpp/asio_srt

# 使用 CMake
mkdir build && cd build
cmake .. -DBUILD_BCAST_EXAMPLES=ON
make

# 运行示例
./src/bcast/bcast_example
./src/bcast/bcast_advanced_example

# 或者直接编译（需要安装 ASIO）
cd src/bcast
g++ -std=c++17 example.cpp -lpthread -o example
./example
```

### 集成到项目

在你的 `CMakeLists.txt` 中：

```cmake
add_subdirectory(src/bcast)
target_link_libraries(your_target PRIVATE bcast)
```

在代码中：

```cpp
#include "dispatcher.hpp"
// 开始使用
```

## 总结

这个发布订阅模式实现提供了：

- 🚀 高性能：无锁设计，低延迟
- 🔒 线程安全：可以从任何线程调用
- 🎯 易用性：简洁的 API
- 💪 健壮性：异常隔离，自动生命周期管理
- 📈 可扩展：支持大量订阅者

适用于各种场景：实时消息系统、事件驱动架构、数据流处理等。

