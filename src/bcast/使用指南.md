# å¼‚æ­¥å‘å¸ƒè®¢é˜…æ¨¡å¼ä½¿ç”¨æŒ‡å—

## ç›®å½•
1. [æ¦‚è¿°](#æ¦‚è¿°)
2. [æ ¸å¿ƒæ¦‚å¿µ](#æ ¸å¿ƒæ¦‚å¿µ)
3. [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
4. [API å‚è€ƒ](#api-å‚è€ƒ)
5. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
6. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
7. [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)

## æ¦‚è¿°

è¿™æ˜¯ä¸€ä¸ªåŸºäº ASIO çš„å¼‚æ­¥ã€æ— é”å‘å¸ƒè®¢é˜…æ¨¡å¼å®ç°ã€‚æ ¸å¿ƒç‰¹ç‚¹ï¼š

- âœ… **æ— é”è®¾è®¡**ï¼šä½¿ç”¨ ASIO strand å®ç°çº¿ç¨‹å®‰å…¨ï¼Œæ— éœ€ mutex
- âœ… **å¼‚æ­¥å¤„ç†**ï¼šæ‰€æœ‰æ“ä½œéƒ½æ˜¯å¼‚æ­¥çš„ï¼Œä¸ä¼šé˜»å¡
- âœ… **ç±»å‹å®‰å…¨**ï¼šä½¿ç”¨ C++ æ¨¡æ¿ï¼Œç¼–è¯‘æœŸç±»å‹æ£€æŸ¥
- âœ… **é«˜æ€§èƒ½**ï¼šé›¶é”å¼€é”€ï¼Œä½å»¶è¿Ÿæ¶ˆæ¯ä¼ é€’
- âœ… **æ˜“äºä½¿ç”¨**ï¼šç®€æ´çš„ APIï¼Œæ”¯æŒ lambda è¡¨è¾¾å¼

## æ ¸å¿ƒæ¦‚å¿µ

### Strandï¼ˆæ‰§è¡Œåºåˆ—ï¼‰

Strand æ˜¯ ASIO æä¾›çš„ä¸€ç§æœºåˆ¶ï¼Œç”¨äºåºåˆ—åŒ–äº‹ä»¶å¤„ç†ï¼š

```
å¤šçº¿ç¨‹ç¯å¢ƒ                 Strand                å¤„ç†å‡½æ•°
   Thread 1  â”€â”€â”
   Thread 2  â”€â”€â”¤â”€â”€> [é˜Ÿåˆ—åŒ–] â”€â”€> æŒ‰åºæ‰§è¡Œ â”€â”€> Handler 1, 2, 3...
   Thread 3  â”€â”€â”˜
```

**ä¼˜åŠ¿**ï¼š
- æ— éœ€æ˜¾å¼é”å®š
- é¿å…ç«æ€æ¡ä»¶
- ä¿è¯æ“ä½œé¡ºåºæ€§

### async_queueï¼ˆå¼‚æ­¥é˜Ÿåˆ—ï¼‰

æ¯ä¸ªè®¢é˜…è€…éƒ½æœ‰ç‹¬ç«‹çš„æ¶ˆæ¯é˜Ÿåˆ—ï¼š

```
å‘å¸ƒè€…                     è®¢é˜…è€…é˜Ÿåˆ—
         â”Œâ”€â”€> Queue 1 â”€â”€> è®¢é˜…è€… 1
Publish â”€â”¼â”€â”€> Queue 2 â”€â”€> è®¢é˜…è€… 2
         â””â”€â”€> Queue 3 â”€â”€> è®¢é˜…è€… 3
```

**ç‰¹æ€§**ï¼š
- ç‹¬ç«‹å¤„ç†ï¼šå„è®¢é˜…è€…äº’ä¸å½±å“
- å¼‚æ­¥æ¨é€ï¼šä¸é˜»å¡å‘å¸ƒè€…
- å¼‚å¸¸éš”ç¦»ï¼šæŸä¸ªè®¢é˜…è€…å‡ºé”™ä¸å½±å“å…¶ä»–è®¢é˜…è€…

### dispatcherï¼ˆåˆ†å‘å™¨ï¼‰

ç®¡ç†æ‰€æœ‰è®¢é˜…è€…ï¼Œè´Ÿè´£æ¶ˆæ¯è·¯ç”±ï¼š

```
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚   Dispatcher    â”‚
              â”‚  [Subscribers]  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚             â”‚             â”‚
   Subscriber 1  Subscriber 2  Subscriber 3
```

## å¿«é€Ÿå¼€å§‹

### 1. åŸºæœ¬ç¤ºä¾‹

```cpp
#include "dispatcher.hpp"
#include <asio.hpp>

int main() {
    // åˆ›å»º io_context
    asio::io_context io_context;
    
    // åˆ›å»º dispatcherï¼ˆå­—ç¬¦ä¸²ç±»å‹æ¶ˆæ¯ï¼‰
    auto dispatcher = bcast::make_dispatcher<std::string>(io_context);
    
    // è®¢é˜…æ¶ˆæ¯
    auto subscriber_id = dispatcher->subscribe([](const std::string& msg) {
        std::cout << "æ”¶åˆ°æ¶ˆæ¯: " << msg << std::endl;
    });
    
    // å‘å¸ƒæ¶ˆæ¯
    dispatcher->publish("Hello, World!");
    dispatcher->publish("è¿™æ˜¯ç¬¬äºŒæ¡æ¶ˆæ¯");
    
    // è¿è¡Œ io_contextï¼ˆå¤„ç†å¼‚æ­¥æ“ä½œï¼‰
    io_context.run();
    
    // å–æ¶ˆè®¢é˜…
    dispatcher->unsubscribe(subscriber_id);
    
    return 0;
}
```

### 2. å¤šè®¢é˜…è€…ç¤ºä¾‹

```cpp
auto dispatcher = bcast::make_dispatcher<int>(io_context);

// è®¢é˜…è€… 1ï¼šæ‰“å°æ‰€æœ‰æ•°å­—
auto sub1 = dispatcher->subscribe([](int value) {
    std::cout << "è®¢é˜…è€…1 æ”¶åˆ°: " << value << std::endl;
});

// è®¢é˜…è€… 2ï¼šåªå¤„ç†å¶æ•°
auto sub2 = dispatcher->subscribe([](int value) {
    if (value % 2 == 0) {
        std::cout << "è®¢é˜…è€…2 å¤„ç†å¶æ•°: " << value << std::endl;
    }
});

// è®¢é˜…è€… 3ï¼šè®¡ç®—ç´¯åŠ å’Œ
int sum = 0;
auto sub3 = dispatcher->subscribe([&sum](int value) {
    sum += value;
    std::cout << "å½“å‰æ€»å’Œ: " << sum << std::endl;
});

// å‘å¸ƒä¸€ç³»åˆ—æ•°å­—
for (int i = 1; i <= 10; ++i) {
    dispatcher->publish(i);
}

io_context.run();
```

### 3. è‡ªå®šä¹‰æ¶ˆæ¯ç±»å‹

```cpp
// å®šä¹‰æ¶ˆæ¯ç»“æ„
struct SensorData {
    std::string sensor_id;
    double temperature;
    double humidity;
    int64_t timestamp;
};

// åˆ›å»º dispatcher
auto dispatcher = bcast::make_dispatcher<SensorData>(io_context);

// è®¢é˜…
auto sub = dispatcher->subscribe([](const SensorData& data) {
    std::cout << "ä¼ æ„Ÿå™¨ " << data.sensor_id 
              << ": æ¸©åº¦=" << data.temperature 
              << "Â°C, æ¹¿åº¦=" << data.humidity << "%" 
              << std::endl;
});

// å‘å¸ƒä¼ æ„Ÿå™¨æ•°æ®
dispatcher->publish(SensorData{
    "sensor_01", 
    25.5, 
    60.0, 
    std::time(nullptr)
});
```

## API å‚è€ƒ

### async_queue<T>

#### æ„é€ å‡½æ•°
```cpp
async_queue(asio::io_context& io_context, message_handler handler)
```

#### æ–¹æ³•

| æ–¹æ³• | æè¿° | çº¿ç¨‹å®‰å…¨ |
|------|------|----------|
| `void push(T msg)` | æ¨é€æ¶ˆæ¯åˆ°é˜Ÿåˆ— | âœ… |
| `void stop()` | åœæ­¢é˜Ÿåˆ—ï¼Œæ¸…ç©ºæ‰€æœ‰æ¶ˆæ¯ | âœ… |
| `void set_error_handler(error_handler h)` | è®¾ç½®å¼‚å¸¸å¤„ç†å™¨ | âŒ |
| `void get_size(callback)` | å¼‚æ­¥è·å–é˜Ÿåˆ—å¤§å° | âœ… |

### dispatcher<T>

#### åˆ›å»º

```cpp
// æ–¹æ³• 1ï¼šç›´æ¥æ„é€ 
auto disp = std::make_shared<bcast::dispatcher<T>>(io_context);

// æ–¹æ³• 2ï¼šä½¿ç”¨å·¥å‚å‡½æ•°ï¼ˆæ¨èï¼‰
auto disp = bcast::make_dispatcher<T>(io_context);
```

#### æ–¹æ³•

| æ–¹æ³• | æè¿° | è¿”å›å€¼ | çº¿ç¨‹å®‰å…¨ |
|------|------|--------|----------|
| `subscribe(handler)` | è®¢é˜…æ¶ˆæ¯ | subscriber_id | âœ… |
| `unsubscribe(id)` | å–æ¶ˆè®¢é˜… | void | âœ… |
| `publish(msg)` | å‘å¸ƒæ¶ˆæ¯ç»™æ‰€æœ‰è®¢é˜…è€… | void | âœ… |
| `get_subscriber_count(callback)` | è·å–è®¢é˜…è€…æ•°é‡ | void | âœ… |
| `clear()` | æ¸…é™¤æ‰€æœ‰è®¢é˜…è€… | void | âœ… |

## æœ€ä½³å®è·µ

### 1. io_context çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†

```cpp
// âŒ é”™è¯¯ï¼šio_context è¿‡æ—©é”€æ¯
void bad_example() {
    asio::io_context io_context;
    auto disp = bcast::make_dispatcher<int>(io_context);
    disp->publish(42);
} // io_context é”€æ¯ï¼Œæ¶ˆæ¯æœªå¤„ç†

// âœ… æ­£ç¡®ï¼šç¡®ä¿ io_context è¿è¡Œ
void good_example() {
    asio::io_context io_context;
    auto disp = bcast::make_dispatcher<int>(io_context);
    
    disp->subscribe([](int v) { 
        std::cout << v << std::endl; 
    });
    
    disp->publish(42);
    
    // è¿è¡Œç›´åˆ°æ‰€æœ‰ä»»åŠ¡å®Œæˆ
    io_context.run();
}
```

### 2. å¤šçº¿ç¨‹ç¯å¢ƒ

```cpp
asio::io_context io_context;
auto dispatcher = bcast::make_dispatcher<std::string>(io_context);

// è®¢é˜…
auto sub = dispatcher->subscribe([](const std::string& msg) {
    // å¤„ç†æ¶ˆæ¯
    std::cout << "[" << std::this_thread::get_id() << "] " << msg << std::endl;
});

// å¯åŠ¨å¤šä¸ªå·¥ä½œçº¿ç¨‹
std::vector<std::thread> workers;
for (int i = 0; i < 4; ++i) {
    workers.emplace_back([&io_context]() {
        io_context.run();
    });
}

// ä»ä»»æ„çº¿ç¨‹å‘å¸ƒæ¶ˆæ¯ï¼ˆçº¿ç¨‹å®‰å…¨ï¼‰
std::thread publisher([&]() {
    for (int i = 0; i < 100; ++i) {
        dispatcher->publish("æ¶ˆæ¯ " + std::to_string(i));
    }
});

publisher.join();

// åœæ­¢å¹¶ç­‰å¾…æ‰€æœ‰å·¥ä½œçº¿ç¨‹
io_context.stop();
for (auto& t : workers) {
    t.join();
}
```

### 3. å¼‚å¸¸å¤„ç†

```cpp
auto queue = std::make_shared<bcast::async_queue<int>>(
    io_context, 
    [](int value) {
        if (value < 0) {
            throw std::runtime_error("è´Ÿæ•°ä¸å…è®¸");
        }
        process(value);
    }
);

// è®¾ç½®å¼‚å¸¸å¤„ç†å™¨
queue->set_error_handler([](const std::exception& e) {
    std::cerr << "å¤„ç†å¼‚å¸¸: " << e.what() << std::endl;
    // è®°å½•æ—¥å¿—ã€å‘é€å‘Šè­¦ç­‰
});
```

### 4. ä½¿ç”¨ shared_ptr ä¼˜åŒ–å¤§æ¶ˆæ¯

```cpp
// å‡è®¾æ¶ˆæ¯å¾ˆå¤§
struct LargeData {
    std::vector<uint8_t> buffer;  // å¯èƒ½æœ‰å‡  MB
    // ... å…¶ä»–å­—æ®µ
};

// âŒ ä½æ•ˆï¼šæ¯ä¸ªè®¢é˜…è€…éƒ½å¤åˆ¶æ•´ä¸ªæ¶ˆæ¯
auto disp1 = bcast::make_dispatcher<LargeData>(io_context);
disp1->publish(large_data);  // å¤åˆ¶å¼€é”€å¤§

// âœ… é«˜æ•ˆï¼šä½¿ç”¨ shared_ptrï¼Œåªå¤åˆ¶æŒ‡é’ˆ
using LargeDataPtr = std::shared_ptr<LargeData>;
auto disp2 = bcast::make_dispatcher<LargeDataPtr>(io_context);

auto data = std::make_shared<LargeData>();
data->buffer.resize(1024 * 1024);  // 1MB
disp2->publish(data);  // åªå¤åˆ¶æŒ‡é’ˆï¼Œå¼€é”€å°
```

### 5. è®¢é˜…è€…ç”Ÿå‘½å‘¨æœŸç®¡ç†

```cpp
class MessageHandler {
public:
    MessageHandler(std::shared_ptr<bcast::dispatcher<int>> disp) 
        : dispatcher_(disp) 
    {
        // è®¢é˜…æ—¶ä¿å­˜ ID
        subscriber_id_ = dispatcher_->subscribe([this](int value) {
            this->handle_message(value);
        });
    }
    
    ~MessageHandler() {
        // ææ„æ—¶è‡ªåŠ¨å–æ¶ˆè®¢é˜…
        if (auto disp = dispatcher_.lock()) {
            disp->unsubscribe(subscriber_id_);
        }
    }
    
private:
    void handle_message(int value) {
        std::cout << "å¤„ç†: " << value << std::endl;
    }
    
    std::weak_ptr<bcast::dispatcher<int>> dispatcher_;
    uint64_t subscriber_id_;
};
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å‡å°‘æ¶ˆæ¯å¤åˆ¶

```cpp
// ä½¿ç”¨ move è¯­ä¹‰
struct Message {
    std::string data;
    Message(std::string d) : data(std::move(d)) {}
};

// æˆ–è€…ä½¿ç”¨ shared_ptr
using MessagePtr = std::shared_ptr<Message>;
```

### 2. æ‰¹é‡å¤„ç†

```cpp
auto dispatcher = bcast::make_dispatcher<int>(io_context);

std::vector<int> batch;
dispatcher->subscribe([&batch](int value) {
    batch.push_back(value);
    
    if (batch.size() >= 100) {
        // æ‰¹é‡å¤„ç† 100 æ¡æ¶ˆæ¯
        process_batch(batch);
        batch.clear();
    }
});
```

### 3. é€‰æ‹©æ€§è®¢é˜…

```cpp
// åœ¨è®¢é˜…è€…å†…éƒ¨è¿‡æ»¤ï¼Œè€Œä¸æ˜¯åˆ›å»ºå¤šä¸ª dispatcher
dispatcher->subscribe([](const Message& msg) {
    // åªå¤„ç†æ„Ÿå…´è¶£çš„æ¶ˆæ¯
    if (msg.type == MessageType::IMPORTANT) {
        handle(msg);
    }
});
```

### 4. io_context çº¿ç¨‹æ± å¤§å°

```cpp
// æ ¹æ® CPU æ ¸å¿ƒæ•°è°ƒæ•´çº¿ç¨‹æ± å¤§å°
unsigned int thread_count = std::thread::hardware_concurrency();

std::vector<std::thread> pool;
for (unsigned int i = 0; i < thread_count; ++i) {
    pool.emplace_back([&io_context]() {
        io_context.run();
    });
}
```

## å¸¸è§é—®é¢˜

### Q1: æ¶ˆæ¯æ²¡æœ‰è¢«å¤„ç†ï¼Ÿ

**A:** ç¡®ä¿ `io_context.run()` è¢«è°ƒç”¨ï¼š

```cpp
io_context.run();  // å¿…é¡»è°ƒç”¨æ‰èƒ½å¤„ç†å¼‚æ­¥æ“ä½œ
```

### Q2: å¦‚ä½•ä¿è¯æ¶ˆæ¯é¡ºåºï¼Ÿ

**A:** å¯¹äºå•ä¸ªè®¢é˜…è€…ï¼Œæ¶ˆæ¯é¡ºåºæ˜¯ä¿è¯çš„ã€‚å¦‚æœéœ€è¦å…¨å±€é¡ºåºï¼Œä½¿ç”¨å•çº¿ç¨‹è¿è¡Œ io_contextï¼š

```cpp
// å•çº¿ç¨‹ï¼Œä¿è¯å…¨å±€é¡ºåº
io_context.run();
```

### Q3: è®¢é˜…è€…å¯ä»¥åœ¨å›è°ƒä¸­å–æ¶ˆè®¢é˜…å—ï¼Ÿ

**A:** å¯ä»¥ï¼Œä½†éœ€è¦å°å¿ƒï¼š

```cpp
uint64_t sub_id;
sub_id = dispatcher->subscribe([&](const Message& msg) {
    if (msg.type == "stop") {
        // å¼‚æ­¥å–æ¶ˆè®¢é˜…ï¼Œé¿å…åœ¨å›è°ƒä¸­ç›´æ¥æ“ä½œ
        asio::post(io_context, [&]() {
            dispatcher->unsubscribe(sub_id);
        });
    }
});
```

### Q4: å¦‚ä½•å®ç°è¯·æ±‚-å“åº”æ¨¡å¼ï¼Ÿ

**A:** ä½¿ç”¨ä¸¤ä¸ª dispatcher æˆ–åœ¨æ¶ˆæ¯ä¸­åŒ…å«å›è°ƒï¼š

```cpp
struct Request {
    int id;
    std::string data;
    std::function<void(Response)> callback;
};

dispatcher->subscribe([](const Request& req) {
    Response resp = process(req.data);
    req.callback(resp);  // è°ƒç”¨å›è°ƒè¿”å›ç»“æœ
});
```

### Q5: æ€§èƒ½ç“¶é¢ˆåœ¨å“ªé‡Œï¼Ÿ

**A:** ä¸»è¦ç“¶é¢ˆï¼š
1. æ¶ˆæ¯å¤åˆ¶ â†’ ä½¿ç”¨ `shared_ptr`
2. è®¢é˜…è€…å¤„ç†æ…¢ â†’ æ¯ä¸ªè®¢é˜…è€…æœ‰ç‹¬ç«‹é˜Ÿåˆ—ï¼Œä¸ä¼šäº’ç›¸é˜»å¡
3. å•çº¿ç¨‹ io_context â†’ ä½¿ç”¨å¤šçº¿ç¨‹æ± 

### Q6: å¦‚ä½•è°ƒè¯•ï¼Ÿ

```cpp
// æ·»åŠ æ—¥å¿—
dispatcher->subscribe([](const Message& msg) {
    std::cout << "[" << std::this_thread::get_id() << "] "
              << "å¤„ç†æ¶ˆæ¯: " << msg.id << std::endl;
});

// ç›‘æ§é˜Ÿåˆ—å¤§å°
queue->get_size([](size_t size) {
    if (size > 1000) {
        std::cout << "è­¦å‘Šï¼šé˜Ÿåˆ—ç§¯å‹ " << size << " æ¡æ¶ˆæ¯" << std::endl;
    }
});
```

## ç¼–è¯‘å’Œè¿è¡Œ

### ç¼–è¯‘ç¤ºä¾‹ç¨‹åº

```bash
cd /home/ubuntu/codes/cpp/asio_srt

# ä½¿ç”¨ CMake
mkdir build && cd build
cmake .. -DBUILD_BCAST_EXAMPLES=ON
make

# è¿è¡Œç¤ºä¾‹
./src/bcast/bcast_example
./src/bcast/bcast_advanced_example

# æˆ–è€…ç›´æ¥ç¼–è¯‘ï¼ˆéœ€è¦å®‰è£… ASIOï¼‰
cd src/bcast
g++ -std=c++17 example.cpp -lpthread -o example
./example
```

### é›†æˆåˆ°é¡¹ç›®

åœ¨ä½ çš„ `CMakeLists.txt` ä¸­ï¼š

```cmake
add_subdirectory(src/bcast)
target_link_libraries(your_target PRIVATE bcast)
```

åœ¨ä»£ç ä¸­ï¼š

```cpp
#include "dispatcher.hpp"
// å¼€å§‹ä½¿ç”¨
```

## æ€»ç»“

è¿™ä¸ªå‘å¸ƒè®¢é˜…æ¨¡å¼å®ç°æä¾›äº†ï¼š

- ğŸš€ é«˜æ€§èƒ½ï¼šæ— é”è®¾è®¡ï¼Œä½å»¶è¿Ÿ
- ğŸ”’ çº¿ç¨‹å®‰å…¨ï¼šå¯ä»¥ä»ä»»ä½•çº¿ç¨‹è°ƒç”¨
- ğŸ¯ æ˜“ç”¨æ€§ï¼šç®€æ´çš„ API
- ğŸ’ª å¥å£®æ€§ï¼šå¼‚å¸¸éš”ç¦»ï¼Œè‡ªåŠ¨ç”Ÿå‘½å‘¨æœŸç®¡ç†
- ğŸ“ˆ å¯æ‰©å±•ï¼šæ”¯æŒå¤§é‡è®¢é˜…è€…

é€‚ç”¨äºå„ç§åœºæ™¯ï¼šå®æ—¶æ¶ˆæ¯ç³»ç»Ÿã€äº‹ä»¶é©±åŠ¨æ¶æ„ã€æ•°æ®æµå¤„ç†ç­‰ã€‚

