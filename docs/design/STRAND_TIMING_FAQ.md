# â“ Strand æ—¶åºé—®é¢˜ FAQ

## æ ¸å¿ƒé—®é¢˜

**Q: å¦‚æœå¤šä¸ª ACORE ç»„ä»¶å…±äº«åŒä¸€ä¸ª strandï¼Œä¼šä¸ä¼šå› ä¸ºä¸²è¡Œæ‰§è¡Œå¯¼è‡´å¡ä½ï¼Ÿ**

**A: ä¸ä¼š - åªè¦æ­£ç¡®ä½¿ç”¨å¼‚æ­¥ API**

---

## ğŸ” æ·±å…¥è§£æ

### åœºæ™¯ï¼šä¸¤ä¸ª mutex å…±äº«ä¸€ä¸ª strand

```cpp
auto shared_strand = asio::make_strand(io_context);
auto mutex1 = std::make_shared<async_mutex>(shared_strand);
auto mutex2 = std::make_shared<async_mutex>(shared_strand);
```

### âœ… æ­£ç¡®ä½¿ç”¨ï¼ˆåç¨‹ï¼‰- ä¸ä¼šå¡ä½

```cpp
asio::co_spawn(shared_strand, [&]() -> asio::awaitable<void> {
    // æ­¥éª¤ 1: å°è¯•é”å®š mutex1
    co_await mutex1->lock(asio::use_awaitable);
    
    // æ­¥éª¤ 2: å°è¯•é”å®š mutex2
    co_await mutex2->lock(asio::use_awaitable);
    
    // æ­¥éª¤ 3: ä¸´ç•ŒåŒº
    critical_section();
    
    // æ­¥éª¤ 4: é‡Šæ”¾é”
    mutex2->unlock();
    mutex1->unlock();
}, asio::detached);
```

**æ‰§è¡Œæµç¨‹**ï¼š

```
æ—¶é—´è½´ | Strand æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T1    â”‚ [åç¨‹] è°ƒç”¨ mutex1->lock()
      â”‚   â†’ å†…éƒ¨ post åˆ° strand: "æ£€æŸ¥ mutex1 æ˜¯å¦å¯ç”¨"
      â”‚   â†’ co_await æš‚åœåç¨‹ âœ… é‡Šæ”¾ strand
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T2    â”‚ [Strand ç©ºé—²] å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
      â”‚   â†’ æ‰§è¡Œ "æ£€æŸ¥ mutex1 æ˜¯å¦å¯ç”¨"
      â”‚   â†’ mutex1 å¯ç”¨ï¼Œæ ‡è®°ä¸ºå·²é”å®š
      â”‚   â†’ è°ƒç”¨åç¨‹çš„ handlerï¼Œæ¢å¤åç¨‹
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T3    â”‚ [åç¨‹] ç»§ç»­æ‰§è¡Œï¼Œè°ƒç”¨ mutex2->lock()
      â”‚   â†’ å†…éƒ¨ post åˆ° strand: "æ£€æŸ¥ mutex2 æ˜¯å¦å¯ç”¨"
      â”‚   â†’ co_await æš‚åœåç¨‹ âœ… é‡Šæ”¾ strand
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T4    â”‚ [Strand ç©ºé—²] å¤„ç†é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
      â”‚   â†’ æ‰§è¡Œ "æ£€æŸ¥ mutex2 æ˜¯å¦å¯ç”¨"
      â”‚   â†’ mutex2 å¯ç”¨ï¼Œæ¢å¤åç¨‹
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T5    â”‚ [åç¨‹] critical_section()
      â”‚ [åç¨‹] é‡Šæ”¾é”ï¼ˆå†…éƒ¨ post åˆ° strandï¼‰
```

**å…³é”®ç‚¹**ï¼š`co_await` ä¼š**æš‚åœ**åç¨‹ï¼Œè®© strand å¯ä»¥æ‰§è¡Œå…¶ä»–ä»»åŠ¡ï¼

---

### âŒ é”™è¯¯ä½¿ç”¨ - ä¼šæ­»é”

```cpp
// âŒ å±é™©ï¼è¿™ä¼šæ­»é”ï¼
asio::post(shared_strand, [&]() {
    // å½“å‰åœ¨ strand ä¸Šæ‰§è¡Œ
    
    bool locked = false;
    
    // å°è¯•é”å®š mutex1
    mutex1->lock([&]() {
        // âŒ è¿™ä¸ªå›è°ƒéœ€è¦ strand æ¥æ‰§è¡Œ
        // ä½† strand æ­£åœ¨æ‰§è¡Œå¤–å±‚ post
        // â†’ æ°¸è¿œä¸ä¼šè¢«è°ƒç”¨
        locked = true;
    });
    
    // âŒ å¦‚æœè¿™é‡Œæœ‰åŒæ­¥ç­‰å¾… locked == true
    // æ°¸è¿œç­‰ä¸åˆ°ï¼
    while (!locked) {
        // æ­»å¾ªç¯ï¼
    }
});
```

**æ‰§è¡Œæµç¨‹**ï¼š

```
æ—¶é—´è½´ | Strand é˜Ÿåˆ—çŠ¶æ€
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T1    â”‚ [æ­£åœ¨æ‰§è¡Œ] post å›è°ƒ
      â”‚   â†’ è°ƒç”¨ mutex1->lock(...)
      â”‚   â†’ mutex1->lock å†…éƒ¨æ·»åŠ ä»»åŠ¡åˆ° strand é˜Ÿåˆ—
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      â”‚ Strand é˜Ÿåˆ—:
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ â”‚ [æ­£åœ¨æ‰§è¡Œ] post å›è°ƒ â† å ç”¨ä¸­    â”‚
      â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ â”‚ [ç­‰å¾…æ‰§è¡Œ] mutex1 å†…éƒ¨ä»»åŠ¡       â”‚ â† æ°¸è¿œæ‰§è¡Œä¸åˆ°
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
T2    â”‚ [æ­£åœ¨æ‰§è¡Œ] post å›è°ƒ
      â”‚   â†’ while (!locked) { } 
      â”‚   â†’ æ­»å¾ªç¯ï¼strand æ°¸è¿œè¢«å ç”¨
      â”‚   â†’ mutex1 çš„å†…éƒ¨ä»»åŠ¡æ°¸è¿œæ— æ³•æ‰§è¡Œ
â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      â”‚ âŒ æ­»é”ï¼
```

**åŸå› **ï¼šå¤–å±‚ post å›è°ƒä¸€ç›´å ç”¨ strandï¼Œå†…å±‚ mutex çš„ä»»åŠ¡æ— æ³•æ‰§è¡Œ

---

## ğŸ¯ ä¸ºä»€ä¹ˆåç¨‹æ˜¯å®‰å…¨çš„ï¼Ÿ

### å…³é”®ï¼š`co_await` çš„é­”æ³•

`co_await` åšäº†ä¸‰ä»¶äº‹ï¼š

1. **æš‚åœå½“å‰åç¨‹** - ä¿å­˜æ‰§è¡ŒçŠ¶æ€
2. **é‡Šæ”¾ strand** - è®© strand å¯ä»¥æ‰§è¡Œå…¶ä»–ä»»åŠ¡
3. **å¼‚æ­¥æ¢å¤** - å½“æ“ä½œå®Œæˆæ—¶ï¼Œé‡æ–°è°ƒåº¦åç¨‹

```cpp
// ä¼ªä»£ç è§£é‡Š co_await çš„å·¥ä½œåŸç†
co_await mutex->lock(asio::use_awaitable);

// ç­‰ä»·äºï¼š
{
    // 1. åˆ›å»ºä¸€ä¸ª"æ¢å¤ç‚¹"
    auto resume_point = save_coroutine_state();
    
    // 2. å‘èµ·å¼‚æ­¥æ“ä½œ
    mutex->lock([resume_point]() {
        // 3. æ“ä½œå®Œæˆåï¼Œæ¢å¤åç¨‹
        resume_coroutine(resume_point);
    });
    
    // 4. æš‚åœåç¨‹ï¼Œé‡Šæ”¾ strand âœ…
    suspend_coroutine();
}

// å½“åç¨‹æ¢å¤æ—¶ï¼Œä»è¿™é‡Œç»§ç»­æ‰§è¡Œ
```

---

## ğŸ“‹ å®é™…ä¾‹å­å¯¹æ¯”

### ä¾‹å­ 1: é˜Ÿåˆ— + äº’æ–¥é”ï¼ˆå…±äº« strandï¼‰

```cpp
auto shared_strand = asio::make_strand(io_context);
auto queue = std::make_shared<async_queue<int>>(shared_strand);
auto mutex = std::make_shared<async_mutex>(shared_strand);

asio::co_spawn(shared_strand, [&]() -> asio::awaitable<void> {
    while (true) {
        // âœ… ç­‰å¾…æ¶ˆæ¯ï¼ˆæš‚åœåç¨‹ï¼‰
        auto [ec, msg] = co_await queue->async_read_msg(asio::use_awaitable);
        
        // âœ… è·å–é”ï¼ˆæš‚åœåç¨‹ï¼‰
        auto guard = co_await mutex->async_lock(asio::use_awaitable);
        
        // å¤„ç†æ¶ˆæ¯
        process(msg);
        
        // guard ææ„ï¼Œé‡Šæ”¾é”
    }
}, asio::detached);
```

**æ‰§è¡Œæ—¶é—´çº¿**ï¼š

```
T1: åç¨‹å¯åŠ¨
  â†’ co_await queue->async_read_msg()
  â†’ åç¨‹æš‚åœ âœ…
  
T2: strand ç©ºé—²ï¼Œå¤„ç† queue çš„å†…éƒ¨æ“ä½œ
  â†’ queue æœ‰æ¶ˆæ¯æ—¶ï¼Œæ¢å¤åç¨‹
  
T3: åç¨‹ç»§ç»­
  â†’ co_await mutex->async_lock()
  â†’ åç¨‹æš‚åœ âœ…
  
T4: strand ç©ºé—²ï¼Œå¤„ç† mutex çš„å†…éƒ¨æ“ä½œ
  â†’ mutex å¯ç”¨æ—¶ï¼Œæ¢å¤åç¨‹
  
T5: åç¨‹ç»§ç»­
  â†’ process(msg)
  â†’ guard ææ„
  â†’ å›åˆ° T1

âœ… æ•´ä¸ªè¿‡ç¨‹æµç•…ï¼Œæ²¡æœ‰é˜»å¡ï¼
```

### ä¾‹å­ 2: 10 ä¸ª mutexï¼ˆå…±äº« strandï¼‰

```cpp
auto shared_strand = asio::make_strand(io_context);
std::vector<std::shared_ptr<async_mutex>> mutexes;

for (int i = 0; i < 10; ++i) {
    mutexes.push_back(std::make_shared<async_mutex>(shared_strand));
}

// å¯åŠ¨ 10 ä¸ªåç¨‹ï¼Œæ¯ä¸ªé”å®šä¸åŒçš„ mutex
for (int i = 0; i < 10; ++i) {
    asio::co_spawn(shared_strand, [i, &mutexes]() -> asio::awaitable<void> {
        auto guard = co_await mutexes[i]->async_lock(asio::use_awaitable);
        // åšä¸€äº›å·¥ä½œ...
        co_await asio::steady_timer(co_await asio::this_coro::executor, 100ms)
            .async_wait(asio::use_awaitable);
    }, asio::detached);
}
```

**ä¼šä¸ä¼šå¡ä½ï¼Ÿ**

**âŒ ä¸ä¼šï¼** 

åŸå› ï¼š

1. æ¯ä¸ª `co_await` éƒ½ä¼šæš‚åœåç¨‹
2. Strand å¯ä»¥è½®æµæ‰§è¡Œæ‰€æœ‰åç¨‹çš„æ“ä½œ
3. æ¯ä¸ª mutex æ˜¯ç‹¬ç«‹çš„ï¼Œä¸ä¼šäº’ç›¸ç­‰å¾…

**æ‰§è¡Œè¿‡ç¨‹**ï¼š

```
Strand çš„ä»»åŠ¡é˜Ÿåˆ—ï¼ˆç®€åŒ–ï¼‰ï¼š

T1: [åç¨‹1] è¯·æ±‚ mutex[0]
    â†’ mutex[0] å¯ç”¨ï¼Œåˆ†é…ç»™åç¨‹1
    â†’ åç¨‹1 æš‚åœï¼ˆç­‰å¾…å®šæ—¶å™¨ï¼‰âœ…
    
T2: [åç¨‹2] è¯·æ±‚ mutex[1]
    â†’ mutex[1] å¯ç”¨ï¼Œåˆ†é…ç»™åç¨‹2
    â†’ åç¨‹2 æš‚åœï¼ˆç­‰å¾…å®šæ—¶å™¨ï¼‰âœ…
    
...

T10: [åç¨‹10] è¯·æ±‚ mutex[9]
     â†’ mutex[9] å¯ç”¨ï¼Œåˆ†é…ç»™åç¨‹10
     â†’ åç¨‹10 æš‚åœï¼ˆç­‰å¾…å®šæ—¶å™¨ï¼‰âœ…
     
T11-T20: å„ä¸ªå®šæ—¶å™¨åˆ°æœŸï¼Œæ¢å¤å¯¹åº”çš„åç¨‹

âœ… æ‰€æœ‰åç¨‹éƒ½èƒ½æ­£å¸¸å®Œæˆï¼
```

---

## âš ï¸ ä»€ä¹ˆæ—¶å€™ä¼šå¡ä½ï¼Ÿ

### åœºæ™¯ 1: åœ¨ strand å›è°ƒä¸­åŒæ­¥ç­‰å¾…

```cpp
asio::post(shared_strand, [&]() {
    // âŒ å½“å‰å ç”¨ strand
    
    mutex->lock([&]() {
        // éœ€è¦ strand æ‰èƒ½æ‰§è¡Œ
        // ä½† strand è¢«å¤–å±‚å ç”¨
    });
    
    // âŒ å¦‚æœè¿™é‡Œç­‰å¾…...
});
```

### åœºæ™¯ 2: ä¸ä½¿ç”¨ co_await

```cpp
asio::co_spawn(shared_strand, [&]() -> asio::awaitable<void> {
    // âŒ é”™è¯¯ï¼šä¸ä½¿ç”¨ co_awaitï¼Œç›´æ¥è°ƒç”¨å›è°ƒ
    bool done = false;
    mutex->lock([&]() {
        done = true;
    });
    
    // âŒ æ­»å¾ªç¯ç­‰å¾…
    while (!done) {
        // åç¨‹ä¸æš‚åœï¼Œstrand æ— æ³•æ‰§è¡Œ mutex çš„æ“ä½œ
    }
}, asio::detached);
```

### åœºæ™¯ 3: å¾ªç¯ä¾èµ–

```cpp
asio::co_spawn(shared_strand, [&]() -> asio::awaitable<void> {
    auto guard1 = co_await mutex1->async_lock(asio::use_awaitable);
    
    // âœ… åˆ°è¿™é‡Œéƒ½æ­£å¸¸
    
    // å¦ä¸€ä¸ªåç¨‹åŒæ—¶åœ¨ç­‰å¾…
    asio::co_spawn(shared_strand, [&]() -> asio::awaitable<void> {
        auto guard2 = co_await mutex2->async_lock(asio::use_awaitable);
        
        // âŒ å°è¯•è·å– mutex1ï¼ˆä½†å·²è¢«ä¸Šé¢çš„åç¨‹æŒæœ‰ï¼‰
        auto guard1 = co_await mutex1->async_lock(asio::use_awaitable);
    }, asio::detached);
    
    // âŒ å°è¯•è·å– mutex2ï¼ˆä½†å·²è¢«å¦ä¸€ä¸ªåç¨‹æŒæœ‰ï¼‰
    auto guard2 = co_await mutex2->async_lock(asio::use_awaitable);
    
    // ç»å…¸æ­»é”ï¼
}, asio::detached);
```

**æ³¨æ„**ï¼šè¿™ä¸æ˜¯ strand çš„é—®é¢˜ï¼Œè€Œæ˜¯é”çš„ä½¿ç”¨é—®é¢˜ï¼ˆä»»ä½•äº’æ–¥é”éƒ½ä¼šæœ‰è¿™ä¸ªé—®é¢˜ï¼‰

---

## âœ… æ€»ç»“

### å…±äº« Strand æ˜¯å®‰å…¨çš„

| ä½¿ç”¨æ–¹å¼ | æ˜¯å¦å¡ä½ | åŸå›  |
|---------|---------|------|
| åç¨‹ + co_await | âœ… ä¸ä¼š | co_await æš‚åœåç¨‹ï¼Œé‡Šæ”¾ strand |
| çº¯å¼‚æ­¥å›è°ƒ | âœ… ä¸ä¼š | å›è°ƒç«‹å³è¿”å›ï¼Œä¸å ç”¨ strand |
| post ä¸­åŒæ­¥ç­‰å¾… | âŒ ä¼š | å ç”¨ strandï¼Œå†…éƒ¨æ“ä½œæ— æ³•æ‰§è¡Œ |
| é”çš„å¾ªç¯ä¾èµ– | âŒ ä¼š | ç»å…¸æ­»é”ï¼ˆä¸ strand æ— å…³ï¼‰ |

### å…³é”®è¦ç‚¹

1. **ACORE ç»„ä»¶çš„è®¾è®¡æ˜¯å¼‚æ­¥çš„** - æ‰€æœ‰æ“ä½œéƒ½é€šè¿‡ `asio::post` è°ƒåº¦
2. **co_await æ˜¯é­”æ³•** - æš‚åœåç¨‹ï¼Œè®© strand å¯ä»¥å¤„ç†å…¶ä»–ä»»åŠ¡
3. **çº¯å›è°ƒä¹Ÿå®‰å…¨** - ä¸é˜»å¡ strandï¼Œå®Œå…¨å¼‚æ­¥
4. **é”™è¯¯ä½¿ç”¨æ‰ä¼šå¡ä½** - åœ¨ strand ä¸ŠåŒæ­¥ç­‰å¾…

### æ¨èåšæ³•

```cpp
// âœ… æ¨èï¼šç›¸å…³ç»„ä»¶å…±äº« strandï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
struct Module {
    asio::strand<asio::any_io_executor> strand_;
    std::shared_ptr<async_queue<msg>> queue_;
    std::shared_ptr<async_mutex> mutex_;
    
    Module(asio::io_context& io)
        : strand_(asio::make_strand(io))
        , queue_(std::make_shared<async_queue<msg>>(strand_))
        , mutex_(std::make_shared<async_mutex>(strand_))
    {}
    
    asio::awaitable<void> process() {
        // âœ… å®‰å…¨ï¼šä½¿ç”¨ co_await
        auto guard = co_await mutex_->async_lock(asio::use_awaitable);
        auto [ec, m] = co_await queue_->async_read_msg(asio::use_awaitable);
        // ...
    }
};
```

---

**æœ€åæ›´æ–°**: 2025-10-20  
**ç›¸å…³æ–‡æ¡£**: [å…±äº« Strand å®‰å…¨æŒ‡å—](SHARED_STRAND_SAFETY.md)

