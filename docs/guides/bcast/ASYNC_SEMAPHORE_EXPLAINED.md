# Async Semaphore è®¾è®¡è¯´æ˜

## ğŸ” å…³äº `release()` "ç«‹å³è¿”å›" çš„é—®é¢˜

### ç”¨æˆ·çš„è§‚å¯Ÿ

ç”¨æˆ·æ­£ç¡®åœ°æŒ‡å‡ºäº† `release()` å‡½æ•°ä¼šç«‹å³è¿”å›ï¼š

```cpp
void release() {
    asio::post(strand_, [this]() {
        // ... å®é™…çš„é‡Šæ”¾é€»è¾‘
    });
    // âš ï¸ å‡½æ•°ç«‹å³è¿”å›ï¼Œlambda å¼‚æ­¥æ‰§è¡Œ
}
```

### è¿™æ˜¯é—®é¢˜å—ï¼Ÿ

**ä¸æ˜¯é—®é¢˜ï¼Œè¿™æ˜¯è®¾è®¡ä¸Šçš„æ­£ç¡®é€‰æ‹©ï¼** åŸå› å¦‚ä¸‹ï¼š

### âœ… ä¸ºä»€ä¹ˆè¿™ä¸ªè®¾è®¡æ˜¯æ­£ç¡®çš„

#### 1. **çº¿ç¨‹å®‰å…¨ä¿è¯**

```cpp
// åœºæ™¯ï¼šå¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨
thread1: sem.release();  // æäº¤åˆ° strand é˜Ÿåˆ—
thread2: sem.release();  // æäº¤åˆ° strand é˜Ÿåˆ—
thread3: co_await sem.acquire();  // æäº¤åˆ° strand é˜Ÿåˆ—
```

- æ‰€æœ‰æ“ä½œéƒ½é€šè¿‡ `asio::post` æäº¤åˆ°**åŒä¸€ä¸ª strand çš„é˜Ÿåˆ—**
- strand ä¿è¯è¿™äº›æ“ä½œ**æŒ‰æäº¤é¡ºåº**ä¸²è¡Œæ‰§è¡Œ
- å³ä½¿ `release()` ç«‹å³è¿”å›ï¼Œå®é™…çš„é‡Šæ”¾æ“ä½œä»ç„¶æ˜¯çº¿ç¨‹å®‰å…¨çš„

#### 2. **éé˜»å¡è®¾è®¡å“²å­¦**

```cpp
// âŒ å¦‚æœä½¿ç”¨é˜»å¡æ–¹å¼
void release() {
    std::lock_guard lock(mutex_);  // é˜»å¡ç­‰å¾…é”
    count_++;
}

// âœ… ä½¿ç”¨å¼‚æ­¥æ–¹å¼
void release() {
    asio::post(strand_, [this]() {  // ç«‹å³è¿”å›
        count_++;
    });
}
```

- ASIO çš„æ ¸å¿ƒç†å¿µæ˜¯**éé˜»å¡**
- ç«‹å³è¿”å›å…è®¸è°ƒç”¨è€…ç»§ç»­æ‰§è¡Œ
- ç‰¹åˆ«é€‚åˆé«˜å¹¶å‘åœºæ™¯

#### 3. **æ€§èƒ½ä¼˜åŠ¿**

| æ“ä½œæ¨¡å¼ | å“åº”æ—¶é—´ | ååé‡ | é€‚ç”¨åœºæ™¯ |
|---------|---------|--------|---------|
| **é˜»å¡** | é«˜ï¼ˆç­‰å¾…é”ï¼‰ | ä½ | ç®€å•åœºæ™¯ |
| **å¼‚æ­¥** | ä½ï¼ˆç«‹å³è¿”å›ï¼‰ | é«˜ | é«˜å¹¶å‘ |

#### 4. **æµ‹è¯•éªŒè¯**

æˆ‘ä»¬çš„å‹åŠ›æµ‹è¯•è¯æ˜äº†è¿™ä¸ªè®¾è®¡çš„æ­£ç¡®æ€§ï¼š

```cpp
// Test 6: Producer-Consumer stress test
// 10 ä¸ªæ¶ˆè´¹è€…ï¼Œ100 æ¡æ¶ˆæ¯
for (int i = 0; i < 100; ++i) {
    sem.release();  // å¿«é€Ÿè¿ç»­è°ƒç”¨ï¼Œç«‹å³è¿”å›
}

// ç»“æœï¼šâœ… Total consumed: 100 (expected: 100)
```

å³ä½¿ `release()` ç«‹å³è¿”å›ï¼Œç”±äº strand çš„ä¸²è¡Œä¿è¯ï¼Œæ‰€æœ‰æ¶ˆæ¯éƒ½è¢«æ­£ç¡®å¤„ç†ã€‚

---

## ğŸ”§ å…³é”®è®¾è®¡ç»†èŠ‚

### 1. Strand çš„ä¸²è¡Œä¿è¯

```cpp
// æ—¶é—´è½´ç¤ºä¾‹
T0: thread1 è°ƒç”¨ release()      â†’ post to strand queue [R1]
T1: thread2 è°ƒç”¨ acquire()      â†’ post to strand queue [R1, A1]
T2: thread3 è°ƒç”¨ release()      â†’ post to strand queue [R1, A1, R2]

// Strand æŒ‰é¡ºåºæ‰§è¡Œï¼š
T3: æ‰§è¡Œ R1 â†’ count++ (count = 1)
T4: æ‰§è¡Œ A1 â†’ count-- (count = 0), å”¤é†’ç­‰å¾…è€…
T5: æ‰§è¡Œ R2 â†’ count++ (count = 1)
```

### 2. ç±»å‹æ“¦é™¤æŠ€æœ¯

æˆ‘ä»¬ä½¿ç”¨äº†ä¸ `async_queue` ç›¸åŒçš„ç±»å‹æ“¦é™¤æŠ€æœ¯æ¥æ”¯æŒ move-only handlersï¼š

```cpp
// Handler æ¥å£ï¼ˆè™šå‡½æ•°ï¼‰
struct handler_base {
    virtual ~handler_base() = default;
    virtual void invoke() = 0;
};

// æ¨¡æ¿å®ç°ï¼ˆå­˜å‚¨å®é™… handlerï¼‰
template<typename Handler>
struct handler_impl : handler_base {
    Handler handler_;
    void invoke() override {
        std::move(handler_)();
    }
};

// å­˜å‚¨ä¸º unique_ptrï¼ˆæ”¯æŒ move-onlyï¼‰
std::deque<std::unique_ptr<handler_base>> waiters_;
```

### 3. åŸå­å˜é‡ä¼˜åŒ–

```cpp
std::atomic<size_t> count_;  // âœ… å…è®¸æ— é”è¯»å–

// å¿«é€Ÿè·¯å¾„ï¼šæ— éœ€è¿›å…¥ strand å°±èƒ½æ£€æŸ¥
size_t count() const noexcept {
    return count_.load(std::memory_order_acquire);
}
```

---

## ğŸ“Š ä¸å…¶ä»–åŒæ­¥åŸè¯­çš„å¯¹æ¯”

### async_event vs async_semaphore

| ç‰¹æ€§ | async_event | async_semaphore |
|------|-------------|----------------|
| **å”¤é†’æ¨¡å¼** | `notify_all()` å”¤é†’æ‰€æœ‰ | `release()` å”¤é†’ä¸€ä¸ª |
| **è®¡æ•°æ”¯æŒ** | æ—  | æœ‰ï¼ˆæ”¯æŒæ‰¹é‡ï¼‰ |
| **é€‚ç”¨åœºæ™¯** | äº‹ä»¶å¹¿æ’­ | ç”Ÿäº§è€…-æ¶ˆè´¹è€… |
| **ç¤ºä¾‹** | è¿æ¥çŠ¶æ€å˜åŒ– | æ¶ˆæ¯é˜Ÿåˆ— |

### ä¸ºä»€ä¹ˆ async_event ä¸é€‚åˆ async_queueï¼Ÿ

```cpp
// âŒ ä½¿ç”¨ async_event çš„é—®é¢˜
queue.push(msg);
event.notify_all();  // å”¤é†’æ‰€æœ‰ 3 ä¸ªæ¶ˆè´¹è€…
// ç»“æœï¼š3 ä¸ªæ¶ˆè´¹è€…äº‰æŠ¢ 1 æ¡æ¶ˆæ¯ â†’ ç«æ€æ¡ä»¶

// âœ… ä½¿ç”¨ async_semaphore çš„æ­£ç¡®åšæ³•
queue.push(msg);
sem.release();  // åªå”¤é†’ 1 ä¸ªæ¶ˆè´¹è€…
// ç»“æœï¼š1 ä¸ªæ¶ˆè´¹è€…è·å– 1 æ¡æ¶ˆæ¯ âœ…
```

---

## ğŸ¯ ä½¿ç”¨å»ºè®®

### ä½•æ—¶ä½¿ç”¨ `release()` ç«‹å³è¿”å›çš„ç‰¹æ€§

**âœ… é€‚åˆçš„åœºæ™¯**ï¼š

1. **æ‰¹é‡ç”Ÿäº§**
   ```cpp
   // å¿«é€Ÿç”Ÿäº§ 1000 æ¡æ¶ˆæ¯
   for (int i = 0; i < 1000; ++i) {
       queue.push(msg);
       sem.release();  // ç«‹å³è¿”å›ï¼Œä¸é˜»å¡
   }
   ```

2. **å¤šç”Ÿäº§è€…**
   ```cpp
   // å¤šä¸ªçº¿ç¨‹å¹¶å‘ç”Ÿäº§
   void producer_thread() {
       while (running) {
           produce_message();
           sem.release();  // çº¿ç¨‹å®‰å…¨ï¼Œä¸é˜»å¡
       }
   }
   ```

3. **å“åº”å¼ç³»ç»Ÿ**
   ```cpp
   // åœ¨å›è°ƒä¸­é‡Šæ”¾ï¼ˆä¸èƒ½é˜»å¡ï¼‰
   void on_data_received() {
       sem.release();  // å¿…é¡»ç«‹å³è¿”å›
       // ç»§ç»­å¤„ç†å…¶ä»–äº‹ä»¶
   }
   ```

**âŒ å¯èƒ½éœ€è¦æ³¨æ„çš„åœºæ™¯**ï¼š

1. **éœ€è¦ç¡®è®¤é‡Šæ”¾å·²å®Œæˆ**
   ```cpp
   sem.release();
   // âš ï¸ è¿™é‡Œä¸èƒ½å‡è®¾ release å·²ç»å®Œæˆ
   // å¦‚æœéœ€è¦ç¡®è®¤ï¼Œè€ƒè™‘ä½¿ç”¨å¼‚æ­¥å›è°ƒ
   ```

2. **ä¸¥æ ¼çš„é¡ºåºè¦æ±‚**ï¼ˆä½†åœ¨ strand ä¸Šä¸‹æ–‡ä¸­ä¸æ˜¯é—®é¢˜ï¼‰
   ```cpp
   // åœ¨åŒä¸€ strand ä¸Šä¸‹æ–‡ä¸­ï¼Œé¡ºåºæ˜¯ä¿è¯çš„
   asio::post(strand, []() {
       sem.release();
       sem.release();
       // ä¿è¯æŒ‰é¡ºåºæ‰§è¡Œ
   });
   ```

---

## ğŸ§ª æµ‹è¯•è¦†ç›–

æˆ‘ä»¬çš„æµ‹è¯•éªŒè¯äº†ä»¥ä¸‹åœºæ™¯ï¼š

1. âœ… **åŸºæœ¬åŠŸèƒ½**ï¼šacquire/release æ­£å¸¸å·¥ä½œ
2. âœ… **å•ä¸€å”¤é†’**ï¼š1 æ¬¡ release åªå”¤é†’ 1 ä¸ªç­‰å¾…è€…
3. âœ… **åˆå§‹è®¡æ•°**ï¼šæ”¯æŒéé›¶åˆå§‹è®¡æ•°
4. âœ… **æ‰¹é‡é‡Šæ”¾**ï¼šæ‰¹é‡ release æ­£ç¡®å·¥ä½œ
5. âœ… **try_acquire**ï¼šéé˜»å¡å°è¯•è·å–
6. âœ… **å‹åŠ›æµ‹è¯•**ï¼š100 æ¡æ¶ˆæ¯ + 10 ä¸ªæ¶ˆè´¹è€…ï¼Œå®Œå…¨æ­£ç¡®

æ‰€æœ‰æµ‹è¯•éƒ½ 100% é€šè¿‡ï¼

---

## ğŸ“ˆ æ€§èƒ½ç‰¹å¾

### æ—¶é—´å¤æ‚åº¦

| æ“ä½œ | æ—¶é—´å¤æ‚åº¦ | è¯´æ˜ |
|------|----------|------|
| `release()` | O(1) | åªæ˜¯ post åˆ°é˜Ÿåˆ— |
| `acquire()` | O(1) amortized | è®¡æ•°æ£€æŸ¥ + å¯èƒ½çš„ç­‰å¾… |
| `count()` | O(1) | åŸå­è¯»å– |

### å†…å­˜å ç”¨

æ¯ä¸ªç­‰å¾…è€…ï¼š
- `unique_ptr<handler_base>`: 8 å­—èŠ‚
- è™šå‡½æ•°è¡¨æŒ‡é’ˆ: 8 å­—èŠ‚
- handler å¯¹è±¡: ~32-64 å­—èŠ‚
- **æ€»è®¡**: ~48-80 å­—èŠ‚/ç­‰å¾…è€…

---

## ğŸ”§ å®ç°ç»†èŠ‚

### å®Œæ•´çš„ release() æµç¨‹

```cpp
void release() {
    // 1. ç«‹å³è¿”å›ï¼Œæäº¤ä»»åŠ¡åˆ° strand
    asio::post(strand_, [this]() {
        // 2. åœ¨ strand ä¸Šä¸²è¡Œæ‰§è¡Œ
        if (!waiters_.empty()) {
            // 3a. æœ‰ç­‰å¾…è€…ï¼šç›´æ¥å”¤é†’
            auto handler = std::move(waiters_.front());
            waiters_.pop_front();
            handler->invoke();  // è°ƒç”¨åç¨‹æ¢å¤
        } else {
            // 3b. æ— ç­‰å¾…è€…ï¼šå¢åŠ è®¡æ•°
            count_.fetch_add(1, std::memory_order_release);
        }
    });
    // 4. å‡½æ•°è¿”å›ï¼ˆå¼‚æ­¥æ“ä½œç»§ç»­ï¼‰
}
```

### å®Œæ•´çš„ acquire() æµç¨‹

```cpp
auto acquire(CompletionToken token) {
    return asio::async_initiate<CompletionToken, void()>(
        [this](auto handler) {
            // 1. æäº¤åˆ° strand
            asio::post(strand_, [this, handler = std::move(handler)]() mutable {
                if (count_ > 0) {
                    // 2a. æœ‰è®¡æ•°ï¼šç«‹å³å®Œæˆ
                    count_--;
                    std::move(handler)();
                } else {
                    // 2b. æ— è®¡æ•°ï¼šåŠ å…¥ç­‰å¾…é˜Ÿåˆ—
                    waiters_.push_back(
                        std::make_unique<handler_impl<...>>(std::move(handler))
                    );
                }
            });
        },
        token
    );
}
```

---

## âœ… æ€»ç»“

### å…³äº "ç«‹å³è¿”å›" çš„é—®é¢˜

| è§‚ç‚¹ | å›ç­” |
|------|------|
| **æ˜¯ bug å—ï¼Ÿ** | âŒ ä¸æ˜¯ï¼Œè¿™æ˜¯æ­£ç¡®çš„è®¾è®¡ |
| **ä¼šå¯¼è‡´é—®é¢˜å—ï¼Ÿ** | âŒ ä¸ä¼šï¼Œstrand ä¿è¯äº†é¡ºåº |
| **æ€§èƒ½å¦‚ä½•ï¼Ÿ** | âœ… ä¼˜ç§€ï¼Œéé˜»å¡è®¾è®¡ |
| **æµ‹è¯•é€šè¿‡å—ï¼Ÿ** | âœ… 100% é€šè¿‡ï¼ŒåŒ…æ‹¬å‹åŠ›æµ‹è¯• |

### å…³é”®è¦ç‚¹

1. **ç«‹å³è¿”å›æ˜¯ç‰¹æ€§ï¼Œä¸æ˜¯ bug**
2. **strand ä¿è¯äº†æ“ä½œçš„ä¸²è¡Œæ‰§è¡Œ**
3. **æ‰€æœ‰æµ‹è¯•éƒ½éªŒè¯äº†æ­£ç¡®æ€§**
4. **è¿™æ˜¯ ASIO æ¨èçš„å¼‚æ­¥æ¨¡å¼**

### ä¸‹ä¸€æ­¥

å¦‚æœéœ€è¦ç¡®è®¤ `release()` å·²ç»å®Œæˆï¼Œå¯ä»¥è€ƒè™‘ï¼š

```cpp
// æ–¹æ¡ˆ 1ï¼šä½¿ç”¨ async_initiate æ¨¡å¼
template<typename CompletionToken>
auto async_release(CompletionToken token) {
    return asio::async_initiate<CompletionToken, void()>(
        [this](auto handler) {
            asio::post(strand_, [this, handler = std::move(handler)]() mutable {
                // ... é‡Šæ”¾é€»è¾‘
                std::move(handler)();  // å®Œæˆæ—¶è°ƒç”¨
            });
        },
        token
    );
}

// ç”¨æ³•ï¼š
co_await sem.async_release(use_awaitable);  // ç­‰å¾…å®Œæˆ
```

ä½†åœ¨å¤§å¤šæ•°åœºæ™¯ä¸­ï¼Œå½“å‰çš„è®¾è®¡å·²ç»å®Œå…¨å¤Ÿç”¨ï¼

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0  
**åˆ›å»ºæ—¥æœŸ**ï¼š2025-10-10  
**æµ‹è¯•çŠ¶æ€**ï¼šâœ… å…¨éƒ¨é€šè¿‡


